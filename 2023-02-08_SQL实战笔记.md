## SQL实战笔记   

更新: 2023-02-08 | 创建: ***2023-02-08***

参考书籍: [《SQL 必知必会》](https://book.douban.com/subject/24250054/)    

![SQL 必知必会](https://img9.doubanio.com/view/subject/s/public/s28341985.jpg)   

*资源直达: [夸克盘](https://pan.quark.cn/s/547e4fe5e6cb) ( 提取码: ACZa )* 

### Part-1  SQL基础知识

#### 1.1 查询操作

- [ ] **检索数据**   

```SQL
SELECT prod_name
FROM Products
ORDER BY prod_name
```

- [ ] **过滤数据**   

```SQL
SELECT prod_name
FROM Products
WHERE prod_price = 3.49
``` 

- [ ] **函数**   

```SQL
  LENGTH ()
  UPPER ()
  LEFT ()
  RIGHT ()
  LOWER ()
  LTRIM ()
  RTRIM ()
``` 

- [ ] **分组数据**   

```SQL
SELECT vend_id, COUNT(*) AS num_prods
FROM Products
WHERE prod_price >= 4
GROUP BY vend_id
HAVING COUNT(*) >= 2
ORDER BY items, order_num
``` 

- [ ] **子查询**   

```SQL
SELECT cust_id
FROM Orders
WHERE order_num IN (SELECT order_num FROM OrderItems WHERE prod_id = 'RGAN01')
``` 

- [ ] **使用视图检索数据**   

```SQL
SELECT cust_name, cust_contact
FROM ProductCustomers
WHERE prod_id = 'RGAN01';
``` 
***ProductCustomers**是一个视图*
*视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询*

#### 1.2 表操作

- [ ] **创建表**   
```SQL
CREATE TABLE Products
(
	prod_id    CHAR(10)      NOT NULL,
	vend_id    CHAR(10)      NOT NULL,
	prod_name  CHAR(254)     NOT NULL,
	prod_proce DECIMAL(8,2)  NOT NULL,
	prod_desc  VARCHAR(1000) NULL
)
```  

- [ ] **更新表**   
```SQL
ALTER TABLE Vendors  
ADD vend_phone CHAR(20);
```  

- [ ] **删除表**   
```SQL
DROP TABLE CustCopy;
```  

- [ ] **简单联结**   
   
　**_方法一_**   

```SQL
SELECT vend_name, prod_name, prod_price
FROM Vendors, Products
WHERE Vendors.vend_id = Products.vend_id;
```  
*注意：在该情况下，要保证所有的联结都有 **WHERE**字句，否则会返回笛卡尔积 ( **cross join** ) 的不正确数据*  

　**_方法二_**  

```SQL
SELECT vend_name, prod_name, prod_price
FROM Vendors INNER JOIN Products
ON Vendors.vend_id = Products.vend_id;
``` 
*使用 **INNER JOIN** 联结时，联结条件用特定的 **ON** 字句而不是 **WHERE**字句*    
***ANSI SQL** 规范首选 **INNER JOIN** 语法*    

- [ ] **多个表联结**   
```SQL
SELECT cust_name, cust_contact
FROM Customers, Orders, OrderItems
WHERE Customers.cust_id = Orders.cust_id
AND OrderItems.order_num = Orders.order_num
AND prod_id = 'RGAN01';
``` 
*子查询并不总是执行复杂SELECT操作最好方法，使用联结查询往往会更有效*


- [ ] **使用带聚集函数的联结**   
```SQL
SELECT Customers.cust_id,
       COUNT(Orders.order_num) AS num_ord
FROM Customers INNER JOIN Orders
ON Customers.cust_id = Orders.cust_id
GROUP BY Customers.cust_id;
``` 
*函数调用 **COUNT ( Orders.order_num )** 对每个顾客的订单计数，将它作为 **num_ord** 返回*
***AS**用于使用表别名*

- [ ] **组合联结**   
```SQL
UNION
UNION ALL 
``` 
*使用 **UNION ALL** 不会取消重复的行*

#### 1.3 数据操作

- [ ] **插入数据**   
```SQL
INSERT INTO Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)
VALUES('10005', 'Toy Land', '123 Any Street', 'New York', 'NY', '11111', 'USA');
``` 

- [ ] **更新数据**   
```SQL
UPDATE Customers
SET cust_email = 'kim@thetoystore.com'
WHERE cust_id = '10005';
``` 

- [ ] **删除数据**   
```SQL
DELETE FROM Customers
WHERE cust_id = '10006';
``` 

### Part-2  SQL 实战

- [ ] LeetCode 练习题-001    
[Employees Earning More Than Their Managers](https://leetcode.com/problems/employees-earning-more-than-their-managers/)    
  → → → 
```SQL
SELECT e1.Name AS Employee FROM Employee e1
JOIN Employee e2
ON e1.ManagerId = e2.Id
WHERE e1.Salary > e2.Salary
```

- [ ] LeetCode 练习题-002    
[Duplicate Emails](https://leetcode.com/problems/duplicate-emails/)   
  → → → 
```SQL
SELECT Email FROM Person
GROUP BY Email
HAVING count(*) > 1;
```

- [ ] LeetCode 练习题-003    
[Combine Two Tables](https://leetcode.com/problems/combine-two-tables/)   
  → → → 
```SQL
SELECT FirstName, LastName, City, State FROM Person
LEFT JOIN Address
ON Person.PersonID = Address.PersonID;
```

- [ ] LeetCode 练习题-004    
[Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/)   
  → → → 
```SQL
SELECT Name AS Customers
FROM Customers LEFT JOIN Orders
ON Customers.ID = Orders.CustomerID
WHERE Orders.CustomerID IS NULL;
```

- [ ] LeetCode 练习题-005    
[Rising Temperature](https://leetcode.com/problems/rising-temperature/)   
  → → → 
```SQL
SELECT t1.Id FROM Weather t1
INNER JOIN Weather t2
ON TO_DAYS(t1.Date)=TO_DAYS(t2.Date) + 1
AND t1.Temperature > t2.Temperature
```

- [ ] LeetCode 练习题-006    
[Second Highest Salary](https://leetcode.com/problems/second-highest-salary/)   
  → → → 
```SQL
SELECT MAX(Salary) FROM Employee
WHERE Salary < (SELECT MAX(Salary) FROM Employee)
```

- [ ] LeetCode 练习题-007    
[Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/)   
  → → → 
```SQL
DELETE p1 FROM Person p1, Person p2
WHERE p1.ID > p2.ID AND p1.Email = p2.Email
```

- [ ] LeetCode 练习题-008    
[Consecutive Numbers](https://leetcode.com/problems/consecutive-numbers/)   
  → → → 
```SQL
SELECT DISTINCT(l1.num)
FROM Logs l1, Logs l2, Logs l3
WHERE l1.ID + 1 = l2.ID
AND l2.ID + 1 = l3.ID
AND l1.Num = l2.Num
AND l2.Num = l3.Num
```

- [ ] LeetCode 练习题-009   ★★★★☆   
[Rank Scores](https://leetcode.com/problems/rank-scores/)   
  → → → 
```SQL
SELECT Scores.Score, COUNT(Ranking.Score) AS RANK
FROM Scores, 
   (
   SELECT DISTINCT Score
   FROM Scores
   ) Ranking
WHERE Scores.Score <= Ranking.Score
GROUP BY Scores.Id, Scores.Score
ORDER BY Scores.Score DESC;
```

- [ ] LeetCode 练习题-010    
[Department Highest Salary](https://leetcode.com/problems/department-highest-salary/)   
  → → → 
```SQL
SELECT D.Name AS Department ,E.Name AS Employee ,E.Salary
FROM Employee E,
    (SELECT DepartmentId,max(Salary) as max
    FROM Employee GROUP BY DepartmentId) T,
    Department D
WHERE E.DepartmentId = T.DepartmentId
AND E.Salary = T.max
AND E.DepartmentId = D.id
```

- [ ] LeetCode 练习题-011    
[Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/)   
  → → → 
```SQL
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
	DECLARE M INT;
	SET M=N-1;
	RETURN (
SELECT DISTINCT Salary
    FROM Employee
    ORDER BY Salary DESC
    LIMIT M, 1);
END
```

【[原文](https://dinglisa.com/blog/2015/11/14/my-database-learning-notes/)】

\* - EOF - \*
